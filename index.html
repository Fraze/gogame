<!DOCTYPE html>
<html>
	<head>
		<title>Go</title>
		<meta charset='utf-8'>
	</head>

	<body>
		<canvas id="go-board" width=500 height=500>

		<script>
"use strict";
var EMPTY = "empty";
var BLACK = "black";
var WHITE = "white";
var NOTHING = "nothing";

var size = 5;
var board = [];
var turn = BLACK;

var stoneSizeRatio = 0.8 / 2;
var canvas = document.getElementById("go-board");
var context = canvas.getContext("2d");
var minSide = Math.min(canvas.width, canvas.height);
var padding = 10;
var cellSize = (minSide - 2 * padding) / size;

var animations = [];

var cachedBackgroundCanvas = document.createElement("canvas");
cachedBackgroundCanvas.width = minSide;
cachedBackgroundCanvas.height = minSide;
var cachedBlackStoneCanvas = document.createElement("canvas");
cachedBlackStoneCanvas.width = cellSize;
cachedBlackStoneCanvas.height = cellSize;
var cachedWhiteStoneCanvas = document.createElement("canvas");
cachedWhiteStoneCanvas.width = cellSize;
cachedWhiteStoneCanvas.height = cellSize;

var stonesCanvas = document.createElement("canvas");
stonesCanvas.width = minSide;
stonesCanvas.height = minSide;

function drawBoardBackground(context) {
	context.save();

	context.fillStyle = "#E2C58B"
	context.fillRect(0, 0, minSide, minSide);

	context.strokeStyle = "rgba(180, 139, 89, 0.4)";
	context.lineWidth = 2;
	context.shadowColor = "rgba(180, 139, 89, 0.9)";
	context.shadowBlur = 3;
	context.shadowOffsetX = -3;
	context.shadowOffsetY = 0;
	context.beginPath();
	var boardBackgroundStreaks = [];
	for (var x = 0; x < minSide; ) {
		x += Math.random() * minSide / 10;
		context.moveTo(x, 0);
		context.lineTo(x + (2 * Math.random() - 1) * 1 * minSide / 30, minSide);
	}
	context.stroke();

	drawBoardLines(context);

	var gradient = context.createLinearGradient(0, 0, minSide, 0);
	gradient.addColorStop(0.00, "rgba(0, 0, 0, 0.05)");
	gradient.addColorStop(0.25, "rgba(255, 255, 255, 0.02)");
	gradient.addColorStop(0.50, "rgba(0, 0, 0, 0.09)");
	gradient.addColorStop(0.70, "rgba(255, 255, 255, 0.01)");
	gradient.addColorStop(1.00, "rgba(0, 0, 0, 0.1)");
	context.fillStyle = gradient;
	context.fillRect(0, 0, minSide, minSide);

	context.restore();
}
function drawBoardLines(context) {
	context.save();
	context.globalAlpha = 0.8;
	context.lineWidth = 4;
	context.strokeStyle = "#333333";
	context.shadowColor = "rgba(10, 10, 10, 0.3)";
	context.shadowBlur = 1;
	context.shadowOffsetX = 1;
	context.shadowOffsetY = 1;
	var offset = padding + cellSize/2;
	context.translate(offset, offset);
	context.beginPath();
	for (var i = 0; i < size; i++) {
		context.moveTo(0, i * cellSize);
		context.lineTo(minSide - offset * 2, i * cellSize);
		context.moveTo(i * cellSize, 0);
		context.lineTo(i * cellSize, minSide - offset * 2);
	}
	context.stroke();
	context.restore();
}
function drawRawStone(context, type) {
	context.save();
	context.translate(cellSize / 2, cellSize / 2);
	context.scale(stoneSizeRatio, stoneSizeRatio);

	context.lineWidth = 1;
	context.shadowColor = "rgba(30, 30, 30, 0.5)";
	context.shadowBlur = 5;
	context.shadowOffsetX = 4;
	context.shadowOffsetY = 4;

	var gradient = context.createRadialGradient(0, 0, cellSize, -cellSize * 0.1, -cellSize * 0.1, cellSize * 0.8);
	if (type == WHITE) {
		context.strokeStyle = "#DDDDDD";
		gradient.addColorStop(0, "#B0B0B0");
		gradient.addColorStop(1, "#DDDDDD");
	} else if (type == BLACK) {
		context.strokeStyle = "#222222";
		gradient.addColorStop(0, "#222222");
		gradient.addColorStop(1, "#333333");
	}
	context.fillStyle = gradient;

	context.beginPath();
	context.arc(0, 0, cellSize, 0, Math.PI*2);
	context.stroke();
	context.fill();

	context.restore();
}

function drawOneStone(context, type, x, y) {
	if (type == EMPTY) {
		return;
	}
	var cachedCanvas = type == WHITE ? cachedWhiteStoneCanvas : cachedBlackStoneCanvas;
	context.drawImage(cachedCanvas, x - cachedCanvas.width / 2, y - cachedCanvas.height / 2);
}
function drawBoardStones(context) {
	context.save();
	context.clearRect(0, 0, minSide, minSide);
	for (var row = 0; row < size; row++) {
		for (var col = 0; col < size; col++) {
			var stone = board[row][col];
			drawOneStone(context, stone.type, stone.pos.x, stone.pos.y);
		}
	}
	context.restore();
}
function translateRowCol(row, col) {
	var wiggleX = (2 * Math.random() - 1) * cellSize * 0.05;
	var wiggleY = (2 * Math.random() - 1) * cellSize * 0.05;
	var x = padding + cellSize/2 + col * cellSize + wiggleX;
	var y = padding + cellSize/2 + row * cellSize + wiggleY;
	return {x: x, y: y};
}

drawRawStone(cachedWhiteStoneCanvas.getContext("2d"), WHITE, 0, 0);
drawRawStone(cachedBlackStoneCanvas.getContext("2d"), BLACK, 0, 0);
drawBoardBackground(cachedBackgroundCanvas.getContext("2d"));

function drawBoard() {
	context.drawImage(cachedBackgroundCanvas, 0, 0);
	context.drawImage(stonesCanvas, 0, 0);
}

function update() {
	drawBoard();
	for (var i = animations.length - 1; i >= 0; i--) {
		context.save();
		var shouldContinue = animations[i]();
		context.restore();
		if (!shouldContinue) {
			animations.splice(i, 1);
		}
	}
	window.requestAnimationFrame(update);
}
window.requestAnimationFrame(update);

function onClick(event) {
	var mouseX = event.pageX - canvas.offsetLeft;
	var mouseY = event.pageY - canvas.offsetTop;
	var col = Math.round((mouseX - padding - cellSize/2) / cellSize);
	var row = Math.round((mouseY - padding - cellSize/2) / cellSize);
	var stone = getStone(row, col);
	if (stone.type != EMPTY) {
		return;	
	}
	stone.type = turn;
	//var removed = sweepBoard();
	var removed = [];
	animatePlay(stone, removed);
	turn = turn === BLACK ? WHITE : BLACK;
}

function animatePlay(stone, removed) {
	var step = 0;
	var direction = stone.type == WHITE ? -1 : 1;
	animations.push(function() {
		context.globalAlpha = step;
		context.translate(stone.pos.x, stone.pos.y + (1 - step) * cellSize * direction * 2);
		context.scale(1.5 - step/2, 1.5 - step/2);
		drawOneStone(context, stone.type, 0, 0);
		step += 0.1;
		if (step <= 1) {
			return true;
		} else {
			for (var removedStone of removed) {
				animateRemoval(removedStone);
			}
			drawBoardStones(stonesCanvas.getContext("2d"));
			return false;
		}
	});
}

function animateRemoval(stone) {
	var step = 0;
	animations.push(function() {
		step += 0.1;
		if (step > 1) {
			return false;
		}
		context.globalAlpha = 1 - step;
		context.translate(stone.pos.x, stone.pos.y);
		context.scale(1 + step/3, 1 + step/3);
		drawOneStone(context, stone.previously, 0, 0);
		return true;
	});
}

function sweepBoard() {
	var groups = calculateGroups();
	console.log(groups);
	var removed = [];
	for (var pos in groups) {
		var group = groups[pos];
		removed.push.apply(removed, group);
		if (group.nLiberties === 0) {
			removeGroup(group);
		}		
	}
	return removed;
}

function removeGroup(group) {
	for (var pos of group.stones) {
		var row = pos[0];
		var col = pos[1];
		var stone = board[row][col];
		stone.previously = stone.type;
		stone.type = EMPTY;
	}
}

function getStone(row, col) {
	if (row < 0 || row >= size || col < 0 || col >= size) {
		return {type: NOTHING};
	}
	return board[row][col];
}

function calculateGroups() {
	var groups = {};
	function addLiberty(stonePos, libertyPos) {
		var group = groups[stonePos];
		if (group) {
			group.liberties[libertyPos] = true;
		}
	}

	for (var row = 0; row < size; row++) {
		for (var col = 0; col < size; col++) {
			var stone = getStone(row, col);
			if (stone.type == EMPTY) {
				continue;
			}

			var top = getStone(row-1, col);
			var left = getStone(row, col-1);
			// This is not right. What happens if a stone connects two
			// existing groups?
			if (stone.type === top.type) {
				groups[stone] = groups[top];
			} else if (stone.type === left.type) {
				groups[stone] = groups[left];
			} else {
				var group = {};
				group.liberties = {};
				group.stones = [];
				groups[[row, col]] = group;
			}
			groups[[row, col]].stones.push([row, col])
		}
	}

	for (var row = 0; row < size; row++) {
		for (var col = 0; col < size; col++) {
			if (getStone(row, col) === EMPTY) {
				addLiberty([row-1, col], [row, col]);
				addLiberty([row+1, col], [row, col]);
				addLiberty([row, col-1], [row, col]);
				addLiberty([row, col+1], [row, col]);
			}
		}
	}

	for (var pos in groups) {
		var group = groups[pos];
		group.nLiberties = Object.keys(group.liberties).length;
	}

	return groups;
}

canvas.onclick = onClick;

for (var row = 0; row < size; row++) {
	board.push([]);
	for (var col = 0; col < size; col++) {
		var pos = translateRowCol(row, col);
		board[row][col] = {type: EMPTY,
						   row: row,
						   col: col,
						   pos: pos};
	}
}
		</script>
	</body>
</html>