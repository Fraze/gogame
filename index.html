<!DOCTYPE html>
<html>
	<head>
		<title>Go</title>
		<meta charset='utf-8'>
	</head>

	<body>
		<canvas id="go-board" width=500 height=500>

		<script>
"use strict";
var EMPTY = "empty";
var BLACK = "black";
var WHITE = "white";
var NOTHING = "nothing";

var size = 5;
var board = [];
var turn = BLACK;

for (var row = 0; row < size; row++) {
	board.push([]);
	for (var col = 0; col < size; col++) {
		board[row][col] = EMPTY;
	}
}

var stoneSizeRatio = 0.8 / 2;
var canvas = document.getElementById("go-board");
var context = canvas.getContext("2d");
var minSide = Math.min(canvas.width, canvas.height);
var padding = 10;
var cellSize = (minSide - 2 * padding) / size;

var backgroundCanvas = document.createElement("canvas");
backgroundCanvas.width = minSide;
backgroundCanvas.height = minSide;

function drawBoardBackground(context) {
	context.save();

	context.fillStyle = "#E2C58B"
	context.fillRect(0, 0, minSide, minSide);

	context.strokeStyle = "rgba(180, 139, 89, 0.4)";
	context.lineWidth = 2;
	context.shadowColor = "rgba(180, 139, 89, 0.9)";
	context.shadowBlur = 3;
	context.shadowOffsetX = -3;
	context.shadowOffsetY = 0;
	context.beginPath();
	var boardBackgroundStreaks = [];
	for (var x = 0; x < minSide; ) {
		x += Math.random() * minSide / 10;
		context.moveTo(x, 0);
		context.lineTo(x + (Math.random() - 1 + 0.5) * 1 * minSide / 30, minSide);
	}
	context.stroke();

	drawBoardLines(context);

	var gradient = context.createLinearGradient(0, 0, minSide, 0);
	gradient.addColorStop(0.00, "rgba(0, 0, 0, 0.05)");
	gradient.addColorStop(0.25, "rgba(255, 255, 255, 0.02)");
	gradient.addColorStop(0.50, "rgba(0, 0, 0, 0.09)");
	gradient.addColorStop(0.70, "rgba(255, 255, 255, 0.01)");
	gradient.addColorStop(1.00, "rgba(0, 0, 0, 0.1)");
	context.fillStyle = gradient;
	context.fillRect(0, 0, minSide, minSide);

	context.restore();
}
drawBoardBackground(backgroundCanvas.getContext("2d"));

function drawBoardLines(context) {
	context.save();
	context.globalAlpha = 0.8;
	context.lineWidth = 4;
	context.strokeStyle = "#333333";
	context.shadowColor = "rgba(10, 10, 10, 0.3)";
	context.shadowBlur = 1;
	context.shadowOffsetX = 1;
	context.shadowOffsetY = 1;
	context.beginPath();
	for (var i = padding + cellSize/2; i <= minSide - padding - cellSize/2; i += cellSize) {
		context.moveTo(padding + cellSize/2, i);
		context.lineTo(minSide - padding - cellSize/2, i);
		context.moveTo(i, padding + cellSize/2);
		context.lineTo(i, minSide - padding - cellSize/2);
	}
	context.stroke();
	context.restore();
}
function drawBoardStones(context) {
	context.save();
	for (var row = 0; row < size; row++) {
		for (var col = 0; col < size; col++) {
			var stone = board[row][col];
			if (stone == EMPTY) {
				continue;
			}

			context.lineWidth = 1;
			context.shadowColor = "rgba(30, 30, 30, 0.5)";
			context.shadowBlur = 5;
			context.shadowOffsetX = 4;
			context.shadowOffsetY = 4;

			var x = padding + cellSize/2 + col * cellSize;
			var y = padding + cellSize/2 + row * cellSize;

			var gradient = context.createRadialGradient(x, y, cellSize * stoneSizeRatio, x - cellSize * 0.1, y - cellSize * 0.1, cellSize * stoneSizeRatio * 0.8);
			if (stone == WHITE) {
				context.strokeStyle = "#DDDDDD";
				gradient.addColorStop(0, "#B0B0B0");
				gradient.addColorStop(1, "#DDDDDD");
			} else if (stone == BLACK) {
				context.strokeStyle = "#222222";
				gradient.addColorStop(0, "#222222");
				gradient.addColorStop(1, "#333333");
			}
			context.fillStyle = gradient;

			context.beginPath();
			context.arc(x, y, cellSize * stoneSizeRatio, 0, Math.PI*2);
			context.stroke();
			context.fill();

			// Attempt at specular light.
			/*
			context.fillStyle = "rgba(255, 255, 255, 0.05)";
			context.shadowColor = "rgba(255, 255, 255, 1)";
			context.shadowBlur = 5;
			context.shadowOffsetX = 3;
			context.shadowOffsetY = 3;
			context.beginPath();
			context.arc(x - cellSize * stoneSizeRatio * 0.35, y - cellSize  * stoneSizeRatio * 0.35, cellSize * stoneSizeRatio * 0.3, 0, Math.PI*2);
			context.fill();
			*/
		}
	}
	context.restore();
}
function drawBoard() {
	context.drawImage(backgroundCanvas, 0, 0);
	drawBoardStones(context);
}

function onClick(event) {
	var mouseX = event.pageX - canvas.offsetLeft;
	var mouseY = event.pageY - canvas.offsetTop;
	var col = Math.round((mouseX - padding - cellSize/2) / cellSize);
	var row = Math.round((mouseY - padding - cellSize/2) / cellSize);
	playAt(row, col);
}

function playAt(row, col) {
	if (getStone(row, col) != EMPTY) {
		return;	
	}
	board[row][col] = turn;
	if (sweepBoard()) {
		turn = turn === BLACK ? WHITE : BLACK;
	} else {
		board[row][col] = EMPTY;
	}
	drawBoard();
}

function sweepBoard() {
	var groups = calculateGroups();
	for (var pos in groups) {
		var group = groups[pos];
		if (group.nLiberties === 0 && group.stones[0] === turn) {
			return false;
		}
	}
	for (var pos in groups) {
		var group = groups[pos];
		if (group.nLiberties === 0) {
			removeGroup(group);
		}		
	}
	return true;
}

function removeGroup(group) {
	for (var pos of group.stones) {
		board[pos[0]][pos[1]] = EMPTY;
	}
}

function getStone(row, col) {
	if (row < 0 || row >= size || col < 0 || col >= size) {
		return NOTHING;
	}
	return board[row][col];
}

function calculateGroups() {
	var groups = {};
	function addLiberty(stonePos, libertyPos) {
		var group = groups[stonePos];
		if (group) {
			group.liberties[libertyPos] = true;
		}
	}

	for (var row = 0; row < size; row++) {
		for (var col = 0; col < size; col++) {
			var stone = getStone(row, col);
			if (stone == EMPTY) {
				continue;
			} else {
				if (stone === getStone(row-1, col)) {
					groups[[row, col]] = groups[[row-1, col]];
				} else if (stone === getStone(row, col-1)) {
					groups[[row, col]] = groups[[row, col-1]];
				} else {
					var group = {};
					group.liberties = {};
					group.stones = [];
					groups[[row, col]] = group;
				}
				groups[[row, col]].stones.push([row, col])
			}
		}
	}

	for (var row = 0; row < size; row++) {
		for (var col = 0; col < size; col++) {
			if (getStone(row, col) === EMPTY) {
				addLiberty([row-1, col], [row, col]);
				addLiberty([row+1, col], [row, col]);
				addLiberty([row, col-1], [row, col]);
				addLiberty([row, col+1], [row, col]);
			}
		}
	}

	for (var pos in groups) {
		var group = groups[pos];
		group.nLiberties = Object.keys(group.liberties).length;
	}

	return groups;
}

drawBoard(5);
canvas.onclick = onClick;
		</script>
	</body>
</html>